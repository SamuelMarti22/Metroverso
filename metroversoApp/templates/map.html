{% load static %}
<!DOCTYPE html>
<html>

<head>


    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <!--MapBox imports-->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>

    <!--Turf import-->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>


    <!--CSS/style imports-->
    <link rel="stylesheet" href="{% static 'css/Stylemap.css' %}">

    <!--JS/js-->
    <script src="{% static 'js/dataTurf.js' %}" onload="console.log('dataTurf cargado');"></script>
    <script src="{% static 'js/functions.js' %}" onload="console.log('functions cargado');"></script>

    <!-- Bootstrap JS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</head>

<body>

    <!--Map Container-->
    <div id="map"></div>

    <!-- Validation alert -->
    <div id="alerta-validacion" class="alert alert-warning alert-dismissible fade show position-absolute top-0 start-50 translate-middle-x mt-3" role="alert" style="display: none; z-index: 9999; max-width: 600px;">
        <span id="mensaje-alerta">Mensaje de alerta aquí</span>
    </div>


    <!-- Sidebar -->
    <div class="sidebar d-flex flex-column">
        <div class="icon d-flex justify-content-center align-items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="35" height="35" fill="#20c997"
                class="bi bi-sign-railroad-fill" viewBox="0 0 16 16">
                <path
                    d="M9.05.435c-.58-.58-1.52-.58-2.1 0L4.224 3.162 8 6.94l3.777-3.777L9.049.435Zm3.274 7.425v-.862h.467c.28 0 .467.154.467.44 0 .28-.182.421-.475.421h-.459Z" />
                <path
                    d="M12.838 4.223 9.06 8l3.777 3.777 2.727-2.728c.58-.58.58-1.519 0-2.098zm.03 2.361c.591 0 .935.334.935.844a.79.79 0 0 1-.485.748l.536 1.074h-.59l-.467-.994h-.473v.994h-.521V6.584h1.064Zm-1.091 6.254L8 9.06l-3.777 3.777 2.728 2.727c.58.58 1.519.58 2.098 0zm-8.953-5.84v.861h.46c.292 0 .474-.14.474-.421 0-.286-.188-.44-.467-.44z" />
                <path
                    d="M3.162 11.777 6.94 8 3.162 4.223.435 6.951c-.58.58-.58 1.519 0 2.098zm-.86-5.193h1.065c.592 0 .936.334.936.844 0 .39-.242.654-.485.748l.536 1.074h-.59l-.467-.994h-.473v.994h-.521V6.584Z" />
            </svg>
        </div>

        <div class="subCategory d-flex justify-content-center align-items-center active" type="button"
            data-bs-toggle="offcanvas" data-bs-target="#offcanvasScrolling" aria-controls="offcanvasScrolling">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor"
                class="bi bi-compass-fill" viewBox="0 0 16 16">
                <path
                    d="M15.5 8.516a7.5 7.5 0 1 1-9.462-7.24A1 1 0 0 1 7 0h2a1 1 0 0 1 .962 1.276 7.5 7.5 0 0 1 5.538 7.24m-3.61-3.905L6.94 7.439 4.11 12.39l4.95-2.828 2.828-4.95z" />
            </svg>
        </div>

        <div class="subCategory d-flex justify-content-center align-items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor"
                class="bi bi-signpost-2-fill" viewBox="0 0 16 16">
                <path
                    d="M7.293.707A1 1 0 0 0 7 1.414V2H2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h5v1H2.5a1 1 0 0 0-.8.4L.725 8.7a.5.5 0 0 0 0 .6l.975 1.3a1 1 0 0 0 .8.4H7v5h2v-5h5a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1H9V6h4.5a1 1 0 0 0 .8-.4l.975-1.3a.5.5 0 0 0 0-.6L14.3 2.4a1 1 0 0 0-.8-.4H9v-.586A1 1 0 0 0 7.293.707" />
            </svg>
        </div>

        <div class="subCategory d-flex justify-content-center align-items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" class="bi bi-radar"
                viewBox="0 0 16 16">
                <path
                    d="M6.634 1.135A7 7 0 0 1 15 8a.5.5 0 0 1-1 0 6 6 0 1 0-6.5 5.98v-1.005A5 5 0 1 1 13 8a.5.5 0 0 1-1 0 4 4 0 1 0-4.5 3.969v-1.011A2.999 2.999 0 1 1 11 8a.5.5 0 0 1-1 0 2 2 0 1 0-2.5 1.936v-1.07a1 1 0 1 1 1 0V15.5a.5.5 0 0 1-1 0v-.518a7 7 0 0 1-.866-13.847" />
            </svg>
        </div>

        <div class="subCategory d-flex justify-content-center align-items-center" type="button"
            data-bs-toggle="offcanvas" data-bs-target="#languageOffcanvas" aria-controls="languageOffcanvas">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" class="bi bi-translate"
                viewBox="0 0 16 16">
                <path
                    d="M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286zm1.634-.736L5.5 3.956h-.049l-.679 2.022z" />
                <path
                    d="M0 2a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v3h3a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-3H2a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zm7.138 9.995q.289.451.63.846c-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.777.665 1.739 1.165 2.93 1.472.133-.254.414-.673.629-.89-1.125-.253-2.057-.694-2.82-1.284.681-.747 1.222-1.651 1.621-2.757H14V8h-3v1.047h.765c-.318.844-.74 1.546-1.272 2.13a6 6 0 0 1-.415-.492 2 2 0 0 1-.94.31" />
            </svg>
        </div>

        <div class="profileIcon d-flex justify-content-center align-items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="white" class="bi bi-person-fill"
                viewBox="0 0 16 16">
                <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6" />
            </svg>
        </div>
    </div>

    <!-- Offcanvas Panel -->
    <div class="offcanvasContainer">
        <div class="offcanvas offcanvas-start" data-bs-scroll="true" data-bs-backdrop="false" tabindex="-1"
            id="offcanvasScrolling" aria-labelledby="offcanvasScrollingLabel">
            <div class="offcanvas-header border-bottom">
                <h5 class="offcanvas-title text-success fw-bold" id="offcanvasScrollingLabel">
                    Planificador de Rutas Metro
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body">
                <div class="divRute">
                    <div class="mb-3">
                        <label for="inputStart" class="form-label text-muted small">Estación de Inicio</label>
                        <input type="text" class="form-control" id="inputStart" placeholder="Inicio">
                    </div>
                    <div class="mb-3">
                        <label for="inputDestination" class="form-label text-muted small">Estación de Destino</label>
                        <input type="text" class="form-control" id="inputDestination" placeholder="Destino">
                    </div>
                    <button class="btn btn-primary w-100 fw-semibold" id="btnSearchRute">
                        <i class="bi bi-search me-2"></i>Buscar Ruta
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Language Offcanvas Panel -->
    <div class="languageContainer">
        <div class="offcanvas offcanvas-start" data-bs-scroll="true" data-bs-backdrop="false" tabindex="-1"
            id="languageOffcanvas" aria-labelledby="languageOffcanvasLabel">
            <div class="offcanvas-header border-bottom">
                <h5 class="offcanvas-title text-success fw-bold" id="languageOffcanvasLabel">
                    Seleccionar Idioma
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body">
                <div class="language-list">
                    <div class="language-item selected" data-lang="es">
                        <div class="language-flag"
                            style="background: linear-gradient(to bottom, #AA151B 0%, #AA151B 33.33%, #F1BF00 33.33%, #F1BF00 66.66%, #AA151B 66.66%, #AA151B 100%);">
                        </div>
                        <span>Español</span>
                        <i class="bi bi-check-circle-fill ms-auto text-success"></i>
                    </div>
                    <div class="language-item" data-lang="en">
                        <div class="language-flag"
                            style="background: linear-gradient(135deg, #012169 25%, transparent 25%) -10px 0, linear-gradient(225deg, #012169 25%, transparent 25%) -10px 0, linear-gradient(315deg, #012169 25%, transparent 25%), linear-gradient(45deg, #012169 25%, transparent 25%); background-size: 20px 20px; background-color: #FFFFFF; position: relative;">
                            <div
                                style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: repeating-linear-gradient(0deg, #FFFFFF 0px, #FFFFFF 2px, #CE1124 2px, #CE1124 4px), repeating-linear-gradient(90deg, #FFFFFF 0px, #FFFFFF 2px, #CE1124 2px, #CE1124 4px);">
                            </div>
                            <div
                                style="position: absolute; top: 0; left: 0; width: 50%; height: 50%; background: #012169;">
                            </div>
                        </div>
                        <span>English</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- User Location Button -->
    <div class="userLocation">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-arms-up"
            viewBox="0 0 16 16">
            <path d="M8 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3" />
            <path
                d="m5.93 6.704-.846 8.451a.768.768 0 0 0 1.523.203l.81-4.865a.59.59 0 0 1 1.165 0l.81 4.865a.768.768 0 0 0 1.523-.203l-.845-8.451A1.5 1.5 0 0 1 10.5 5.5L13 2.284a.796.796 0 0 0-1.239-.998L9.634 3.84a.7.7 0 0 1-.33.235c-.23.074-.665.176-1.304.176-.64 0-1.074-.102-1.305-.176a.7.7 0 0 1-.329-.235L4.239 1.286a.796.796 0 0 0-1.24.998l2.5 3.216c.317.316.475.758.43 1.204Z" />
        </svg>
    </div>

    <!-- User Location Button -->
    <div class="userLocation1" id="btnUserLocationOrigin">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-arms-up"
            viewBox="0 0 16 16">
            <path d="M8 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3" />
            <path
                d="m5.93 6.704-.846 8.451a.768.768 0 0 0 1.523.203l.81-4.865a.59.59 0 0 1 1.165 0l.81 4.865a.768.768 0 0 0 1.523-.203l-.845-8.451A1.5 1.5 0 0 1 10.5 5.5L13 2.284a.796.796 0 0 0-1.239-.998L9.634 3.84a.7.7 0 0 1-.33.235c-.23.074-.665.176-1.304.176-.64 0-1.074-.102-1.305-.176a.7.7 0 0 1-.329-.235L4.239 1.286a.796.796 0 0 0-1.24.998l2.5 3.216c.317.316.475.758.43 1.204Z" />
        </svg>
    </div>
    <div class="userLocation2" id="btnUserLocationDestiny">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-arms-up"
            viewBox="0 0 16 16">
            <path d="M8 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3" />
            <path
                d="m5.93 6.704-.846 8.451a.768.768 0 0 0 1.523.203l.81-4.865a.59.59 0 0 1 1.165 0l.81 4.865a.768.768 0 0 0 1.523-.203l-.845-8.451A1.5 1.5 0 0 1 10.5 5.5L13 2.284a.796.796 0 0 0-1.239-.998L9.634 3.84a.7.7 0 0 1-.33.235c-.23.074-.665.176-1.304.176-.64 0-1.074-.102-1.305-.176a.7.7 0 0 1-.329-.235L4.239 1.286a.796.796 0 0 0-1.24.998l2.5 3.216c.317.316.475.758.43 1.204Z" />
        </svg>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibGFjYXRyaWxmIiwiYSI6ImNtZG00eGJqZjAxMGYyaXBrcGY3b2tjYzIifQ.gx3C4J17a-6YrUBt6sZTmQ';

        const initialLocationView = [-75.5752, 6.2491]; // Coordinates of San Antonio

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/standard', // Style of the map
            config: {
                basemap: {
                    theme: 'monochrome'
                }
            },
            center: initialLocationView,
            zoom: 15
        });

        let inRoute = false; // Flag to check if in route mode
        let userLocation = null;
        let lastUserLocation = null; // Store last location for comparison
        let userMarker = null;
        let blueLocationMarker = null; // Store blue marker reference
        let watchId = null;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 1000; // Update interval in milliseconds
        const STATION_UPDATE_THRESHOLD = 10; // Update stations when user moves more than 50 meters

        // Function to get user location
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        updateUserLocation(position);
                        startLocationTracking();
                    },
                    handleLocationError,
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            }
        }

        // Function to update user location
        function updateUserLocation(position) {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const currentTime = Date.now();

            // Limit very frequent updates
            if (currentTime - lastUpdateTime < UPDATE_INTERVAL) {
                return;
            }

            console.log("Location accuracy:", Math.round(accuracy * 100) / 100, "m");
            //if (accuracy > 100) {
            //    console.warn("Low location precision");
            //    return;
            //}

            const newUserLocation = [userLng, userLat];

            // Check if user has moved significantly before updating closest stations
            let shouldUpdateStations = false;
            if (!lastUserLocation) {
                shouldUpdateStations = true; // First time getting location
            } else {
                const distance = turf.distance(
                    turf.point(lastUserLocation),
                    turf.point(newUserLocation),
                    { units: 'meters' }
                );
                if (distance > STATION_UPDATE_THRESHOLD) {
                    shouldUpdateStations = true;
                }
            }

            userLocation = newUserLocation;
            lastUpdateTime = currentTime;

            // Update closest stations only if user has moved significantly
            if (shouldUpdateStations) {
                closestStations(turf.point(userLocation), 2000);
                lastUserLocation = [...userLocation]; // Store copy of current location
            }

            if (!userMarker) {
                // Create custom marker
                const markerElement = document.createElement('div');
                markerElement.innerHTML = '📍';
                markerElement.style.fontSize = '20px';
                markerElement.style.cursor = 'pointer';

                userMarker = new mapboxgl.Marker({ element: markerElement })
                    .setLngLat([userLng, userLat])
                    .setPopup(new mapboxgl.Popup({
                        closeButton: false,
                        offset: [0, -10]
                    }).setText('Tu ubicación'))
                    .addTo(map);
            } else {
                // If marker already exists, just update its position
                userMarker.setLngLat([userLng, userLat]);
            }
        }

        // Function to start optimized tracking
        function startLocationTracking() {
            watchId = navigator.geolocation.watchPosition(
                updateUserLocation,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: UPDATE_INTERVAL
                }
            );
        }

        // Function to handle location errors
        function handleLocationError(error) {
            console.warn('Could not get location:', error.message);

            switch (error.code) {
                case error.PERMISSION_DENIED:
                    console.warn('Permission denied to access location.');
                    break;
                case error.POSITION_UNAVAILABLE:
                    console.warn('Location information is not available.');
                    break;
                case error.TIMEOUT:
                    console.warn('Location request timed out.');
                    break;
                default:
                    console.warn('Error getting location.');
                    break;
            }
        }

        // Function to stop location tracking
        function stopLocationTracking() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        // Function to force update closest stations
        function forceUpdateClosestStations() {
            if (userLocation) {
                closestStations(turf.point(userLocation), 2000);
                lastUserLocation = [...userLocation];
            }
        }

        // Function to get walking route
        async function walkingRoute(start, end) {
            const query = await fetch(
                `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${end[0]},${end[1]}?steps=true&geometries=geojson&overview=full&approaches=unrestricted;unrestricted&access_token=${mapboxgl.accessToken}`,
                { method: 'GET' }
            );
            const json = await query.json();
            const data = json.routes[0];
            return data;
        }

        // Function to add route to map
        function addRouteToMap(route, routeId = 'walking-route') {
            // Remove existing route if it exists
            if (map.getSource(routeId)) {
                map.removeLayer(routeId);
                map.removeSource(routeId);
            }

            // Add route source and layer
            map.addSource(routeId, {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    properties: {},
                    geometry: route.geometry
                }
            });

            map.addLayer({
                id: routeId,
                type: 'line',
                source: routeId,
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#4CAF50',
                    'line-width': 4,
                    'line-opacity': 0.8,
                    'line-dasharray': [2, 2]
                }
            });
        }

        // Function to find the closest stations to the user location
        function closestStations(userPoint, maxDistance) {
            // Remove existing layers and sources if they exist
            if (map.getLayer('distance-labels')) map.removeLayer('distance-labels');
            if (map.getLayer('points-layer')) map.removeLayer('points-layer');
            if (map.getLayer('lines-layer')) map.removeLayer('lines-layer');
            if (map.getSource('points')) map.removeSource('points');
            if (map.getSource('lines')) map.removeSource('lines');

            if (inRoute) return; // Skip if in route mode

            const top3 = closestPoints(userPoint, 2000);
            console.log("Closest points:", top3);

            const pointsGeoJSON = {
                "type": "FeatureCollection",
                "features": top3.map(p => ({
                    "type": "Feature",
                    "geometry": p.geometry,
                    "properties": {
                        "ID": p.properties.ID,
                    }
                }))
            };


            const linesGeoJSON = {
                "type": "FeatureCollection",
                "features": top3.map(p => {

                    const distance = turf.distance(userPoint, p, { units: 'meters' });

                    return {
                        "type": "Feature",
                        "geometry": {
                            "type": "LineString",
                            "coordinates": [
                                userPoint.geometry.coordinates,
                                p.geometry.coordinates
                            ]
                        },
                        "properties": {
                            "distance": `${distance.toFixed(0)} m`  // round to meters
                        }
                    };
                })
            };


            map.addSource('points', { "type": "geojson", "data": pointsGeoJSON });
            map.addSource('lines', { "type": "geojson", "data": linesGeoJSON });


            map.addLayer({
                "id": "lines-layer",
                "type": "line",
                "source": "lines",
                "layout": {
                    "line-join": "round",
                    "line-cap": "round"
                },
                "paint": {
                    "line-color": "#FF0000",
                    "line-width": 2
                }
            });


            map.addLayer({
                "id": "points-layer",
                "type": "circle",
                "source": "points",
                "paint": {
                    "circle-color": "#FF0000",
                    "circle-radius": 6,
                    "circle-stroke-width": 2,
                    "circle-stroke-color": "#FFFFFF"
                }
            });


            map.addLayer({
                "id": "distance-labels",
                "type": "symbol",
                "source": "lines",
                "layout": {
                    "symbol-placement": "line",
                    "text-field": ["get", "distance"],
                    "text-size": 14,
                    "text-offset": [0, 0.5]
                },
                "paint": {
                    "text-color": "#000000",
                    "text-halo-color": "#FFFFFF",
                    "text-halo-width": 1
                }
            });
        }

        console.log("Map initialized");
        map.on('load', () => {

            getUserLocation();

            const lastPoint = turf.point([-75.581547, 6.194671]);
            const destination = turf.point([-75.585684, 6.191629]);

            // Get walking route and draw it
            walkingRoute(lastPoint.geometry.coordinates, destination.geometry.coordinates)
                .then(route => {
                    addRouteToMap(route, "lastRoute");
                })
                .catch(error => {
                    console.error('Error getting route:', error);
                });
        });


        map.on('click', 'points-layer', (e) => {
            const feature = e.features[0];

            new mapboxgl.Popup()
                .setLngLat(feature.geometry.coordinates)
                .setHTML(`
            <b>ID:</b> ${feature.properties.ID || 'Sin ID'}<br>
            <b>Distance:</b> ${feature.properties.distance || 'N/A'}
        `)
                .addTo(map);
        });

        // Function to go to user location
        document.querySelector('.userLocation').addEventListener('click', function () {
            if (userMarker) {
                map.flyTo({
                    center: userMarker.getLngLat(),
                    zoom: 15,
                    essential: true
                });
            } else {
                console.warn('No se ha podido encontrar la ubicación.');
            }
        });

        // End closest points function

        // Rute finding function
        document.getElementById('btnSearchRute').addEventListener('click', function () {
            const inputStart = document.getElementById('inputStart').value;
            const inputDestination = document.getElementById('inputDestination').value;

            const alertBox = document.getElementById("alerta-validacion");
            const alertMessage = document.getElementById("mensaje-alerta");

            const validationResult = validateInputsAndStations(inputStart, inputDestination, pointsStations, validateLocation);
            if (!validationResult.valid) {
                showAutoClosingAlert(alertBox, alertMessage, validationResult.message);
                return;
            }

            const { startPoint, endPoint } = validationResult;

            // Hide alert if all is valid
            alertBox.style.display = "none";

            console.log(`Inicio: ${inputStart}, Destino: ${inputDestination}`);

            fetch(`/view/callRute?inputStart=${inputStart}&inputDestination=${inputDestination}`)
                .then(res => res.json())
                .then(data => {
                    console.log('Ruta:', data.rute);
                    console.log('Distancia:', data.distance);
                    console.log('Información de transferencias:', data.transfer_info);

                    displayTransferInfo(data.transfer_info, data.rute);
                });

            // Adjust map view to include both points
            const bounds = new mapboxgl.LngLatBounds();
            bounds.extend(startPoint.geometry.coordinates);
            bounds.extend(endPoint.geometry.coordinates);
            map.fitBounds(bounds, { padding: 40 });
        });

        // End rute finding function

        function displayTransferInfo(transferInfo, route) {
            let infoContainer = document.getElementById('routeInfo');
            if (!infoContainer) {
                infoContainer = document.createElement('div');
                infoContainer.id = 'routeInfo';
                infoContainer.style.marginTop = '10px';
                infoContainer.style.padding = '10px';
                infoContainer.style.backgroundColor = '#f8f9fa';
                infoContainer.style.borderRadius = '5px';
                document.querySelector('.divRute').appendChild(infoContainer);
            }

            let html = `<h6>Información de Ruta</h6>`;
            html += '<p class="route-chain"><strong>Ruta completa:</strong> '
                + window.renderRouteChain(route, transferInfo)
                + '</p>';

            if (transferInfo.requires_transfer) {
                html += `<p><strong>Se requieren ${transferInfo.transfer_count} transferencia(s)</strong></p>`;
                html += `<p><strong>Estaciones de transferencia:</strong></p>`;
                html += `<ul>`;
                transferInfo.transfer_stations.forEach(station => {
                    html += `<li>Transferencia en: <strong>${station}</strong></li>`;
                });
                html += `</ul>`;
            } else {
                html += `<p><strong>No se requieren transferencias</strong></p>`;
                html += `<p>Viaje directo en la línea ${transferInfo.line_segments[0]?.line}</p>`;
            }

            // How to make transfers
            if (transferInfo.requires_transfer) {
            const segs = transferInfo.line_segments;
            const transferHints = [];

            for (let i = 1; i < segs.length; i++) {
                const prev = segs[i - 1];
                const curr = segs[i];
                const transferStation = prev.stations[prev.stations.length - 1];
                const newLine = curr.line;
                const nextStation = curr.stations.length > 1 ? curr.stations[1] : transferStation;

                transferHints.push(
                `En <strong>${transferStation}</strong> cambia a la línea <strong>${newLine}</strong> y dirígete a <strong>${nextStation}</strong>.`
                );
            }

            html += `
                <hr class="my-2">
                <h6 class="mb-2 text-success fw-bold">seguimiento de transbordos</h6>
                <div class="small">
                ${transferHints.map(h => `<div>• ${h}</div>`).join("")}
                </div>
            `;
            }
            infoContainer.innerHTML = html;
        }

        // Handle sidebar active states
        document.querySelectorAll('.subCategory').forEach(item => {
            item.addEventListener('click', function () {
                // Remove active class from all items
                document.querySelectorAll('.subCategory').forEach(el => el.classList.remove('active'));
                // Add active class to clicked item
                this.classList.add('active');
            });
        });

        // Language selection functionality
        document.querySelectorAll('.language-item').forEach(item => {
            item.addEventListener('click', function () {
                // Remove selected class from all items
                document.querySelectorAll('.language-item').forEach(i => {
                    i.classList.remove('selected');
                    const icon = i.querySelector('.bi-check-circle-fill');
                    if (icon) icon.remove();
                });

                // Add selected class to clicked item
                this.classList.add('selected');

                // Add check icon
                if (!this.querySelector('.bi-check-circle-fill')) {
                    const checkIcon = document.createElement('i');
                    checkIcon.className = 'bi bi-check-circle-fill ms-auto text-success';
                    this.appendChild(checkIcon);
                }
            });
        });

        // Selecting a destination point

        let selecting = 0;
        let selectedCoord = null;
        let markerOrigin = null;
        let markerDestiny = null;
        let mapContainer = document.getElementById("map")

        document.getElementById("btnUserLocationOrigin").addEventListener("click", () => {
            selecting = 1;
            map.getCanvas().classList.add("crosshair");
            console.log("🟢 Modo selección activado (Origen): haz clic en el mapa");
        });

        document.getElementById("btnUserLocationDestiny").addEventListener("click", () => {
            selecting = 2;
            map.getCanvas().classList.add("crosshair");
            console.log("🟢 Modo selección activado (Destino): haz clic en el mapa");
        });

        // If a user clicks the map
        map.on("click", (e) => {
            if (selecting === 0) return; // no estamos seleccionando
            console.log("Holi")
            if (selecting === 1) {
                // inicio
                selectedCoordOrigin = [e.lngLat.lng, e.lngLat.lat];

                if (markerOrigin) {
                    markerOrigin.setLngLat(selectedCoordOrigin);
                } else {
                    markerOrigin = new mapboxgl.Marker({ color: "blue" })
                        .setLngLat(selectedCoordOrigin)
                        .addTo(map);
                }
            } else {
                // destino
                selectedCoordDestiny = [e.lngLat.lng, e.lngLat.lat];

                if (markerDestiny) {
                    markerDestiny.setLngLat(selectedCoordDestiny);
                } else {
                    markerDestiny = new mapboxgl.Marker({ color: "red" })
                        .setLngLat(selectedCoordDestiny)
                        .addTo(map);
                }
            }
            // Salimos del modo selección
            selecting = 0;
            map.getCanvas().classList.remove("crosshair");
        });
    </script>

</body>

</html>